[{"title":"typescript的接口","url":"/2019/11/13/typescript接口/","content":"\n#### 接口\n###### 1.对class类的约束\n```javascript\n// 接口定义\ninterface Iprinter{\n\tPrinting(msg:string):string;\n}\ninterface Imessage{\n\tgetMsg():string;\n}\n// 实现接口\nclass colorprinter implements Iprinter{\n\tPrinting(msg:string):string{\n\t\treturn '打印' + msg + '成功！'\n\t}\n\tgetMsg():string{\n\t\treturn 'hello world'\n\t}\n}\nlet p1 = new colorprinter()\nconsole.log(p1.Printing('简历'))\n\n// 实现接口要实现里面的内容\n// 定义接口的时候，只定义里面的声明即可，不包含具体内容\n```\n\n###### 2.对函数的约束\n\n```javascript\ninterface Comfun{\n\t(a:string,b:number):boolean\n}\nlet fun:Comfun\nfun = function(a:string,b:number):boolean{\n\treturn true\n}\n```\n\n###### 3.对数组的约束\n\n```javascript\ninterface Islist{\n\t[index:number]:string\n}\nlet arr:Islist\narr = ['a','b']\n```\n###### 4.对json的约束\n\n```javascript\ninterface Isjson{\n\tname:string,\n\treadonly age:number, // 只读属性\n\temail?:string // 可选属性\n}\nfunction desc(n:Isjson){\n\tconsole.log(JSON.stringify(n))\n}\ndesc({name:'Xiao Ming',age:18})\n```\n","tags":["typescript","接口"]},{"title":"typescript的基础类型","url":"/2019/11/12/typescript的基础类型/","content":"\n#### 一.基础类型\n\n##### 1.字符串\n```javascript\nlet name:string = 'Xiao Ming'\nlet isDesc:string = `${name} is a  handsome guy`\n```\n##### 2.Boolean\n\n```javascript\nlet isShow:boolean = true\n```\n##### 3.数字\n\n```javascript\nlet age:number = 18\n```\n##### 4.数组\n\n```javascript\nlet arr:number[] = [1,2,3]\n// Array<T>\n```\n##### 5.元组\n\n```javascript\nlet arr:[number,string] = [18,'Xiao Ming']\n```\n##### 6.枚举\n\n```javascript\nenum Weeks = { 'Mon','Tue','Wed' }\nlet day:Weeks = Weeks.Mon\nconsole.log(day)  // 0\nconsole.log(Weeks[0])  // 'Mon'\nconsole.log(Weeks['Mon'])  // 0\n```\n##### 7.Any (任何类型）\n\n##### 8.undefined  null\n\n##### 9.void\n\n==没有任何类型，当作函数返回值==\n\n```javascript\nfunction hello():void{\n\tconsole.log('hello')\n}\nfunction hello1():string{\n\treturn 'hello'\n}\n```\n#### 二.联合类型\n\n```javascript\nlet data:string | number | boolean = 123\n```\n\n#### 三.类型推论\n\n```javascript\nlet data = 123  // number类型\nlet data1； // Any类型\n```\n#### 四.类型断言\n\n```javascript\nlet data:string | number | boolean = 'Xiao Ming is a boy'\nlet len:number = (<string>data).length\nlet len:number = (data as string).length\n```\n\n\n","tags":["typescript","基础类型"]},{"title":"js简单封装ajax请求","url":"/2019/07/10/js简单封装ajax请求/","content":"\n```javascript\n        function showList(data) {\n            console.log(data)\n        }\n        var xhr = null;\n        ajaxFunc('post', './data.php', 'username=liao', true, showList)\n\n        function ajaxFunc(method, url, data, flag, callback) {\n            // 兼容处理\n            if (window.XMLHttpRequest) {\n                xhr = new XMLHttpRequest();\n            } else {\n                xhr = new ActiveXObject('Microsoft.XMLHttp');\n            }\n            method = method.toUpperCase();\n            xhr.open(method, url, flag); // method  url 同步异步\n            if (method == 'POST') {\n                xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); // post请求必须设置头部\n            }\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState == 4) {\n                    if (xhr.status == 200) {\n                        callback(xhr.responseText)\n                    }\n                }\n            }\n            xhr.send(data);\n        }\n```\n### 详细描述\n属性|描述\n-|:-\nXMLHttpRequest|所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）\nopen(method,url,async)|规定请求类型，url，是否同步异步<br>  1.method：请求的类型，GET 或 POST <br>2.url：文件在服务器上的位置 <br>3.async：true（异步）或 false（同步）\nsend(string)|将请求发送到服务器,string仅用于post请求\nsetRequestHeader(header,value)|向请求添加 HTTP 头。header: 规定头的名称。value: 规定头的值\nonreadystatechange|状态改变的时间触发器\nreadyState|对象状态（integer），状态值 <br>0 = 未初始化，未调用send()方法<br>1 = 读取中，已调用send()方法，正在发送请求<br>2 = 已读取，send()方法已完成，接受到全部响应内容<br>3 = 交互中，正在解析响应内容<br>4 = 完成，响应内容全部完成\nresponseText|获得字符串形式的响应数据\nresponseXMl|获得XML形式的相应数据\nstatus|服务器返回的状态码，如：404 = 文件没找到，200 = 成功，500 = 服务器内部错误，304 = 资源被修改\nstatusText|服务器返回的状态文本信息\n\n\n\n\n","tags":["ajax","js"]},{"title":"防抖节流","url":"/2019/07/09/防抖节流/","content":"\n#### 防抖（debounce）\n指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。\n\n应用：实时搜索\n\n```javascript\n function debounce(handler, delay) {\n     var timer = null\n     return function () {\n         var _self = this,\n             _arg = arguments;\n         clearTimeout(timer)\n         timer = setTimeout(function () {\n             handler.apply(_self, _arg)\n         }, delay)\n     }\n }\n function ajax(e) {\n     console.log(e)\n }\n oInp.onclick = debounce(ajax, 2000)\n```\n#### 节流（throttle）\n指连续触发事件但是在 n 秒中只执行一次函数。\n\n应用：窗口调整（resize），页面滚动（scroll），抢购疯狂点击。\n\n```javascript\n function throttle(handler, wait) {\n     var lastTime = 0\n     return function () {\n         var nowTime = new Date().getTime()\n         if (nowTime - lastTime > wait) {\n             handler.apply(this, argumrnts)\n             lastTime = nowTime\n         }\n     }\n }\n\n function ajax(e) {\n     console.log(e)\n }\n oBtn.oncilck = throttle(ajax, 1000)\n```\n\n\n","tags":["js"]}]
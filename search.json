[{"title":"函数柯里化","url":"/2019/11/20/函数柯里化/","content":"\n### 柯里化定义\n    柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。\n\n### 作用\n    1.参数复用 – 复用最初函数的第一个参数\n    2.提前返回 – 返回接受余下的参数且返回结果的新函数\n    3.延迟执行 – 返回新函数，等待执行（其余拓展：防抖节流）\n\n### 函数特点\n    1.复用第一个参数\n    2.返回新函数\n    3.收集剩余参数\n    4.返回结果\n\n#### 参数复用，提前返回，延迟执行\n\n1.add(1)(2,3,4,5)()   add(1,2)(3,4)(5)()   // 15\n\n```javascript\n\tfunction add(){\n\t\tlet _arg = [...arguments]  // Array.prototype.slice.call(arguments)  Array.from(arguments)\n\t\tconst inner = function(){\n\t\t\tif(arguments.length === 0){\n\t\t\t\treturn _arg.reduce((pre,cur)=> pre + cur)\n\t\t\t}else{\n\t\t\t\t_arg.push(...arguments)  //[].push.apply(_args, arguments)\n\t\t\t\treturn inner\n\t\t\t}\n\t\t}\n\t\treturn inner\n\t}\n\tconsole.log(add(1,2)(3)(4)(5)())  //15\n```\n2.add(1)(2,3,4,5)   add(1,2)(3,4)(5)   // 15\n\n```javascript\n\tfunction add(){\n\t\tlet _arg = [...arguments]\n\t\tconst inner = function(){\n\t\t\t_arg.push(...arguments)\n\t\t\treturn inner\n\t\t}\n\t\t// 重写toString()，先调用的toString返回值了，valueOf不行\n\t\t// toString.valueOf 知识点\n\t\tinner.toString = function(){\n\t\t\treturn _arg.reduce((pre,cur) => pre + cur)\n\t\t}\n\t\treturn inner\n\t}\n\tconsole.log(add(1,2)(3,4)(5)) //f 15\n\ttypeof add(1,2)(3,4)(5)  //\"function\"\n```\n3.事件监听\n\n```javascript\n\t//不考虑柯里化，正常如下封装(每次调用函数都会在次判断if else)\n\tconst whichEvent = function(element,type,listener,useCapture){\n\t\tif(window.addEventListener){\n\t\t\telement.addEventListener(type,listener,useCapture)\n\t\t}else if(window.attachEvent){\n\t\t\tele.attachEvent(\"on\" + type, listener)\n\t\t}\n\t}\n\t\n\t// 柯里化处理(立即执行函数)\n\tconst whichEvent = (function(){\n\t\tif(window.addEventListener){\n\t\t\treturn function(element,type,listener,useCapture){\n\t\t\t\telement.addEventListener(type,functioin(e){\n\t\t\t\t\tlistener.call(element,e)\n\t\t\t\t},useCapture)\n\t\t\t}\n\t\t}else if(window.attachEvent){\n\t\t\treturn function(element,type,handler){\n\t\t\t\telement.attachEvent(\"on\" + type,function(e){\n\t\t\t\t\thandler.call(element,e)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t})()\n```\n4.参数复用例子\n\n```javascript\n\tconst list_one = [{\n\t\tgame:'PUBG',\n\t\ttype:'射击'\n\t},{\n\t\tgame:'LOL',\n\t\ttype:'竞技'\n\t}]\n\tconst list_two = [{\n\t\tname:'UZI',\n\t\trole:'bot'\n\t},{\n\t\tname:'FAKE',\n\t\trole:'mid'\n\t}]\n\tconst currying = name => element => element[name]\n\tconst game_sel = currying('game')\n\tconst name_sel = currying('name')\n\tconsole.log(list_one.map(game_sel)) // [ 'PUBG', 'LOL' ]\n\tconsole.log(list_two.map(name_sel)) // [ 'UZI', 'FAKE' ]\n```\n5.封装一个柯里化函数\n\n```javascript\n\tfunction hi(name,age,school){\n\t\treturn `您好！我是${name},${age}岁，毕业于${school}`\n\t}\n\tfunction curry(fn){\n\t\tconst len = fn.length  //形参个数，没有形参则为0，但是arguments.length可能不为0\n\t\treturn function inner(){\n\t\t\tlet _arg = [...arguments]\n\t\t\tif(_arg.length >= len){\n\t\t\t\treturn fn(..._arg)\n\t\t\t}else{\n\t\t\t\treturn function(){\n\t\t\t\t\treturn inner(..._arg,...arguments)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlet c =  curry(hi)\n\tconsole.log(c('小明')('20')('清华'))\n```","tags":["柯里化"]},{"title":"typescript的接口","url":"/2019/11/13/typescript接口/","content":"\n#### 接口\n###### 1.对class类的约束\n```javascript\n// 接口定义\ninterface Iprinter{\n\tPrinting(msg:string):string;\n}\ninterface Imessage{\n\tgetMsg():string;\n}\n// 实现接口\nclass colorprinter implements Iprinter{\n\tPrinting(msg:string):string{\n\t\treturn '打印' + msg + '成功！'\n\t}\n\tgetMsg():string{\n\t\treturn 'hello world'\n\t}\n}\nlet p1 = new colorprinter()\nconsole.log(p1.Printing('简历'))\n\n// 实现接口要实现里面的内容\n// 定义接口的时候，只定义里面的声明即可，不包含具体内容\n```\n\n###### 2.对函数的约束\n\n```javascript\ninterface Comfun{\n\t(a:string,b:number):boolean\n}\nlet fun:Comfun\nfun = function(a:string,b:number):boolean{\n\treturn true\n}\n```\n\n###### 3.对数组的约束\n\n```javascript\ninterface Islist{\n\t[index:number]:string\n}\nlet arr:Islist\narr = ['a','b']\n```\n###### 4.对json的约束\n\n```javascript\ninterface Isjson{\n\tname:string,\n\treadonly age:number, // 只读属性\n\temail?:string // 可选属性\n}\nfunction desc(n:Isjson){\n\tconsole.log(JSON.stringify(n))\n}\ndesc({name:'Xiao Ming',age:18})\n```\n","tags":["typescript","接口"]},{"title":"typescript的基础类型","url":"/2019/11/12/typescript的基础类型/","content":"\n#### 一.基础类型\n\n##### 1.字符串\n```javascript\nlet name:string = 'Xiao Ming'\nlet isDesc:string = `${name} is a  handsome guy`\n```\n##### 2.Boolean\n\n```javascript\nlet isShow:boolean = true\n```\n##### 3.数字\n\n```javascript\nlet age:number = 18\n```\n##### 4.数组\n\n```javascript\nlet arr:number[] = [1,2,3]\n// Array<T>\n```\n##### 5.元组\n\n```javascript\nlet arr:[number,string] = [18,'Xiao Ming']\n```\n##### 6.枚举\n\n```javascript\nenum Weeks = { 'Mon','Tue','Wed' }\nlet day:Weeks = Weeks.Mon\nconsole.log(day)  // 0\nconsole.log(Weeks[0])  // 'Mon'\nconsole.log(Weeks['Mon'])  // 0\n```\n##### 7.Any (任何类型）\n\n##### 8.undefined  null\n\n##### 9.void\n\n==没有任何类型，当作函数返回值==\n\n```javascript\nfunction hello():void{\n\tconsole.log('hello')\n}\nfunction hello1():string{\n\treturn 'hello'\n}\n```\n#### 二.联合类型\n\n```javascript\nlet data:string | number | boolean = 123\n```\n\n#### 三.类型推论\n\n```javascript\nlet data = 123  // number类型\nlet data1； // Any类型\n```\n#### 四.类型断言\n\n```javascript\nlet data:string | number | boolean = 'Xiao Ming is a boy'\nlet len:number = (<string>data).length\nlet len:number = (data as string).length\n```\n\n\n","tags":["typescript","基础类型"]},{"title":"js简单封装ajax请求","url":"/2019/07/10/js简单封装ajax请求/","content":"\n```javascript\n        function showList(data) {\n            console.log(data)\n        }\n        var xhr = null;\n        ajaxFunc('post', './data.php', 'username=liao', true, showList)\n\n        function ajaxFunc(method, url, data, flag, callback) {\n            // 兼容处理\n            if (window.XMLHttpRequest) {\n                xhr = new XMLHttpRequest();\n            } else {\n                xhr = new ActiveXObject('Microsoft.XMLHttp');\n            }\n            method = method.toUpperCase();\n            xhr.open(method, url, flag); // method  url 同步异步\n            if (method == 'POST') {\n                xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); // post请求必须设置头部\n            }\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState == 4) {\n                    if (xhr.status == 200) {\n                        callback(xhr.responseText)\n                    }\n                }\n            }\n            xhr.send(data);\n        }\n```\n### 详细描述\n属性|描述\n-|:-\nXMLHttpRequest|所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）\nopen(method,url,async)|规定请求类型，url，是否同步异步<br>  1.method：请求的类型，GET 或 POST <br>2.url：文件在服务器上的位置 <br>3.async：true（异步）或 false（同步）\nsend(string)|将请求发送到服务器,string仅用于post请求\nsetRequestHeader(header,value)|向请求添加 HTTP 头。header: 规定头的名称。value: 规定头的值\nonreadystatechange|状态改变的时间触发器\nreadyState|对象状态（integer），状态值 <br>0 = 未初始化，未调用send()方法<br>1 = 读取中，已调用send()方法，正在发送请求<br>2 = 已读取，send()方法已完成，接受到全部响应内容<br>3 = 交互中，正在解析响应内容<br>4 = 完成，响应内容全部完成\nresponseText|获得字符串形式的响应数据\nresponseXMl|获得XML形式的相应数据\nstatus|服务器返回的状态码，如：404 = 文件没找到，200 = 成功，500 = 服务器内部错误，304 = 资源被修改\nstatusText|服务器返回的状态文本信息\n\n\n\n\n","tags":["ajax","js"]},{"title":"防抖节流","url":"/2019/07/09/防抖节流/","content":"\n#### 防抖（debounce）\n指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。\n\n应用：实时搜索\n\n```javascript\n function debounce(handler, delay) {\n     var timer = null\n     return function () {\n         var _self = this,\n             _arg = arguments;\n         clearTimeout(timer)\n         timer = setTimeout(function () {\n             handler.apply(_self, _arg)\n         }, delay)\n     }\n }\n function ajax(e) {\n     console.log(e)\n }\n oInp.onclick = debounce(ajax, 2000)\n```\n#### 节流（throttle）\n指连续触发事件但是在 n 秒中只执行一次函数。\n\n应用：窗口调整（resize），页面滚动（scroll），抢购疯狂点击。\n\n```javascript\n function throttle(handler, wait) {\n     var lastTime = 0\n     return function () {\n         var nowTime = new Date().getTime()\n         if (nowTime - lastTime > wait) {\n             handler.apply(this, argumrnts)\n             lastTime = nowTime\n         }\n     }\n }\n\n function ajax(e) {\n     console.log(e)\n }\n oBtn.oncilck = throttle(ajax, 1000)\n```\n\n\n","tags":["js"]}]